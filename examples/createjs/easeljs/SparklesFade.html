<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>EaselJS 示例: 使用 Stage.autoClear</title>

	<link href="assets/demoStyles.css" rel="stylesheet" type="text/css" />

	<script type="text/javascript" src="../../../src/xc.js"></script>

    <script>
    xc.depends([
        "../../../src/core",
        "../../../src/lib/createjs"
    ], function() {
		var canvas, stage, oldX=0;
	
		var imgSeq = new Image();		// 作为那些星星动画的图片
		var bmpAnim;						// 用作克隆使用的星星动画模板
	
		function init() {
			if (window.top != window) {
				document.getElementById("header").style.display = "none";
			}
	
			// 在canvas上创建一个场景
			canvas = document.getElementById("testCanvas");
			stage = new createjs.Stage(canvas);
	        stage.enableDOMEvents(true);
	        // 开始加载图片精灵，等待其加载完毕
			imgSeq.onload = handleImageLoad;
			imgSeq.src = "assets/sparkle_21x23.png";
		}
	
		function handleImageLoad() {
			// 对canvas添加鼠标事件
            // 为了跨平台，相对于直接在canvas上添加，更建议使用以下方式：
			stage.addEventListener("stagemousemove", moveCanvas);
			stage.addEventListener("stagemousedown", clickCanvas);
	
	        // 创建一个覆盖整个场景的黑色半透明矩形
			// 在每次循环的时候画上这个会使canvas褪回黑色
			var shape = new createjs.Shape(new createjs.Graphics().beginFill('#333').drawRect(0,0,canvas.width+1,canvas.height));
			shape.alpha = 0.35;
			stage.addChild(shape);
	
	        // 这个是用来阻止场景在每次循环中的自我清空行为
			// 在这个示例中，它在星星的足迹上体现，那些之前画上去的还一直停留在屏幕上
			stage.autoClear = false;
	
			// 定义了需要使用的简单的图片精灵数据、帧的尺寸和该帧在场景上的坐标
            // 系统会自动从图片集中计算帧的数量并循环播放
			var data = {
				images: ["assets/sparkle_21x23.png"],
				frames: {width:21,height:23,regX:10,regY:11}
			}
	        
	        // 设置一个动画实例，方便我们进行克隆
			bmpAnim = new createjs.BitmapAnimation(new createjs.SpriteSheet(data));
	
			// 开始进入主循环
			createjs.Ticker.addEventListener("tick", tick);
		}
	
		function tick() {
			var h = canvas.height;
			var w = canvas.width;
	
			// 对场景上的所有星星进行遍历
			var l = stage.getNumChildren();
			for (var i=l-1; i>0; i--) {
				var sparkle = stage.getChildAt(i);
	
				// 应用重力和摩擦力
				sparkle.vY += 2;
				sparkle.vX *= 0.98;
	
				// 更新位置、缩放和透明度
				sparkle.x += sparkle.vX;
				sparkle.y += sparkle.vY;
				sparkle.alpha += sparkle.vA;
	
	
				//把已经隐藏或停止的星星移除掉
				if (sparkle.alpha <= 0 || sparkle.y>=h && sparkle.vY < 10) {
					stage.removeChildAt(i);
				}
				
				//把星星从底部反弹回去
				if (sparkle.y > h) {
					sparkle.vY *= -(Math.random()*0.4+0.4);
					sparkle.y -= sparkle.y%h;
				}
				if (sparkle.x >= w || sparkle.x <= 0) { sparkle.vX *= -1; }
			}
	
			// 把更新的内容描绘到场景上
			stage.update();
		}
	
		//星星爆炸
		function clickCanvas(evt) {
			addSparkles(Math.random()*100+100|0, evt.stageX, evt.stageY, 2, 0);
		}
	
		//星星轨迹
		function moveCanvas(evt) {
			addSparkles(Math.random()*2+1|0, evt.stageX, evt.stageY, 1, evt.stageX-oldX);
			oldX = evt.stageX;
		}
	
		function addSparkles(count, x, y, speed, velX) {
			//创建指定数量的星星
			for (var i=0; i<count; i++) {
				// 复制原始的星星，这样我们就不用共享那些属性了
				var sparkle = bmpAnim.clone();
	
				// 设置显示属性
				sparkle.x = x;
				sparkle.y = y;
				sparkle.alpha = Math.random()*0.5+0.5;
				sparkle.scaleX = sparkle.scaleY = Math.random()+0.3;
				sparkle.compositeOperation = "lighter";
	
				// 设置速率
				var a = Math.PI*2*Math.random();
				var v = (Math.random()-0.5)*30*speed;
				sparkle.vX = Math.cos(a)*v+velX;
				sparkle.vY = Math.sin(a)*v;
				sparkle.vA = -Math.random()*0.05-0.01; // 透明度
	
				// 在一个随机的帧上开始动画
				sparkle.gotoAndPlay(Math.random()*sparkle.spriteSheet.getNumFrames()|0);
	
				// 添加到显示列表
				stage.addChild(sparkle);
			}
		}
		init();
	});
	</script>
</head>

<body>
	<header id="header" class="EaselJS">
	    <h1><span class="text-product">Easel<strong>JS</strong></span> 星星示例（消退）</h1>
	    <p>跟sparkles.html类似，展示了把<strong>Stage.autoClear</strong>设为false时的效果。尝试移动鼠标和点击鼠标，注：那个半透明的黑色矩形<strong>Shape</strong>是画在每帧里面所有图形之上的，会把它们褪回黑色
	    </p>
	</header>

	<div class="canvasHolder">
		<canvas id="testCanvas" width="960" height="400"></canvas>
	</div>
</body>
</html>
