<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/EaselJS_16x16.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
	<title>xc v0.1.0 API Documentation : ..\src\lib\createjs\easeljs\display\Container.js</title>  
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><a href="http:&#x2F;&#x2F;www.createjs.com&#x2F;#!&#x2F;EaselJS"><img src="http:&#x2F;&#x2F;createjs.com&#x2F;resources&#x2F;SuiteIcons&#x2F;EaselJS&#x2F;docs-icon-EaselJS.png" title="xc"></a></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Documentation for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/AlphaMapFilter.html">AlphaMapFilter</a></li>
            
                <li><a href="..&#x2F;classes/AlphaMaskFilter.html">AlphaMaskFilter</a></li>
            
                <li><a href="..&#x2F;classes/Bitmap.html">Bitmap</a></li>
            
                <li><a href="..&#x2F;classes/BitmapAnimation.html">BitmapAnimation</a></li>
            
                <li><a href="..&#x2F;classes/BoxBlurFilter.html">BoxBlurFilter</a></li>
            
                <li><a href="..&#x2F;classes/ColorFilter.html">ColorFilter</a></li>
            
                <li><a href="..&#x2F;classes/ColorMatrix.html">ColorMatrix</a></li>
            
                <li><a href="..&#x2F;classes/ColorMatrixFilter.html">ColorMatrixFilter</a></li>
            
                <li><a href="..&#x2F;classes/Command.html">Command</a></li>
            
                <li><a href="..&#x2F;classes/Container.html">Container</a></li>
            
                <li><a href="..&#x2F;classes/CSSPlugin.html">CSSPlugin</a></li>
            
                <li><a href="..&#x2F;classes/DisplayObject.html">DisplayObject</a></li>
            
                <li><a href="..&#x2F;classes/Ease.html">Ease</a></li>
            
                <li><a href="..&#x2F;classes/EventDispatcher.html">EventDispatcher</a></li>
            
                <li><a href="..&#x2F;classes/Filter.html">Filter</a></li>
            
                <li><a href="..&#x2F;classes/Graphics.html">Graphics</a></li>
            
                <li><a href="..&#x2F;classes/HTMLAudioLoader.html">HTMLAudioLoader</a></li>
            
                <li><a href="..&#x2F;classes/HTMLAudioPlugin.html">HTMLAudioPlugin</a></li>
            
                <li><a href="..&#x2F;classes/Log.html">Log</a></li>
            
                <li><a href="..&#x2F;classes/Matrix2D.html">Matrix2D</a></li>
            
                <li><a href="..&#x2F;classes/MotionGuidePlugin.html">MotionGuidePlugin</a></li>
            
                <li><a href="..&#x2F;classes/MouseEvent.html">MouseEvent</a></li>
            
                <li><a href="..&#x2F;classes/MovieClip.html">MovieClip</a></li>
            
                <li><a href="..&#x2F;classes/MovieClipPlugin.html">MovieClipPlugin</a></li>
            
                <li><a href="..&#x2F;classes/Point.html">Point</a></li>
            
                <li><a href="..&#x2F;classes/Rectangle.html">Rectangle</a></li>
            
                <li><a href="..&#x2F;classes/Shadow.html">Shadow</a></li>
            
                <li><a href="..&#x2F;classes/Shape.html">Shape</a></li>
            
                <li><a href="..&#x2F;classes/Sound.html">Sound</a></li>
            
                <li><a href="..&#x2F;classes/SoundChannel.html">SoundChannel</a></li>
            
                <li><a href="..&#x2F;classes/SoundInstance.html">SoundInstance</a></li>
            
                <li><a href="..&#x2F;classes/SpriteSheet.html">SpriteSheet</a></li>
            
                <li><a href="..&#x2F;classes/SpriteSheetBuilder.html">SpriteSheetBuilder</a></li>
            
                <li><a href="..&#x2F;classes/SpriteSheetUtils.html">SpriteSheetUtils</a></li>
            
                <li><a href="..&#x2F;classes/Stage.html">Stage</a></li>
            
                <li><a href="..&#x2F;classes/TagPool.html">TagPool</a></li>
            
                <li><a href="..&#x2F;classes/Text.html">Text</a></li>
            
                <li><a href="..&#x2F;classes/Ticker.html">Ticker</a></li>
            
                <li><a href="..&#x2F;classes/Timeline.html">Timeline</a></li>
            
                <li><a href="..&#x2F;classes/Touch.html">Touch</a></li>
            
                <li><a href="..&#x2F;classes/Tween.html">Tween</a></li>
            
                <li><a href="..&#x2F;classes/UID.html">UID</a></li>
            
                <li><a href="..&#x2F;classes/WebAudioLoader.html">WebAudioLoader</a></li>
            
                <li><a href="..&#x2F;classes/WebAudioPlugin.html">WebAudioPlugin</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/xc.html">xc</a></li>
            
                <li><a href="..&#x2F;modules/xc.core.html">xc.core</a></li>
            
                <li><a href="..&#x2F;modules/xc.createjs.html">xc.createjs</a></li>
            
                <li><a href="..&#x2F;modules/xc.createjs.easeljs.html">xc.createjs.easeljs</a></li>
            
                <li><a href="..&#x2F;modules/xc.createjs.soundjs.html">xc.createjs.soundjs</a></li>
            
                <li><a href="..&#x2F;modules/xc.createjs.tweenjs.html">xc.createjs.tweenjs</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
            <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <script>
	var name = ..\src\lib\createjs\easeljs\display\Container.js      
</script>
<h1 class="file-heading">File:..\src\lib\createjs\easeljs\display\Container.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
xc.module.define(&quot;xc.createjs.Container&quot;, function(exports) {

  var DisplayObject = xc.module.require(&quot;xc.createjs.DisplayObject&quot;);

  &#x2F;**
   * A Container is a nestable display list that allows you to work with compound display elements. For example you
   * could group arm, leg, torso and head {{#crossLink &quot;Bitmap&quot;}}{{&#x2F;crossLink}} instances together into a Person
   * Container, and transform them as a group, while still being able to move the individual parts relative to each
   * other. Children of containers have their &lt;code&gt;transform&lt;&#x2F;code&gt; and &lt;code&gt;alpha&lt;&#x2F;code&gt; properties concatenated with
   * their parent Container.
   *
   * For example, a {{#crossLink &quot;Shape&quot;}}{{&#x2F;crossLink}} with x=100 and alpha=0.5, placed in a Container with &lt;code&gt;x=50&lt;&#x2F;code&gt;
   * and &lt;code&gt;alpha=0.7&lt;&#x2F;code&gt; will be rendered to the canvas at &lt;code&gt;x=150&lt;&#x2F;code&gt; and &lt;code&gt;alpha=0.35&lt;&#x2F;code&gt;.
   * Containers have some overhead, so you generally shouldn&#x27;t create a Container to hold a single child.
   *
   * &lt;h4&gt;Example&lt;&#x2F;h4&gt;
   *     var container = new Container();
   *     container.addChild(bitmapInstance, shapeInstance);
   *     container.x = 100;
   *
   * @class Container
   * @extends DisplayObject
   * @constructor
   *&#x2F;
  var Container = DisplayObject.extend({
    _init: function() {
      this._super();
      this.children = [];
    },

    &#x2F;**
     * The array of children in the display list. You should usually use the child management methods such as
     * {{#crossLink &quot;Container&#x2F;addChild&quot;}}{{&#x2F;crossLink}}, {{#crossLink &quot;Container&#x2F;removeChild&quot;}}{{&#x2F;crossLink}},
     * {{#crossLink &quot;Container&#x2F;swapChildren&quot;}}{{&#x2F;crossLink}}, etc, rather than accessing this directly, but it is
     * included for advanced users.
     *
     * @property children
     * @type Array
     * @default null
     *&#x2F;
    children: null,

    &#x2F;**
     * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
     * This does not account for whether it would be visible within the boundaries of the stage.
     *
     * Note: This method is mainly for internal use, though it may be useful for advanced uses.
     *
     * @method isVisible
     * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
     *&#x2F;
    isVisible: function() {
      var hasContent = this.cacheCanvas || this.children.length;
      return !!(this.visible &amp;&amp; this.alpha &gt; 0 &amp;&amp; this.scaleX != 0 &amp;&amp; this.scaleY != 0 &amp;&amp; hasContent);
    },

    &#x2F;**
     * Draws the display object into the specified context ignoring it&#x27;s visible, alpha, shadow, and transform.
     * Returns true if the draw was handled (useful for overriding functionality).
     *
     * Note: This method is mainly for internal use, though it may be useful for advanced uses.
     *
     * @method draw
     * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
     * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.
     *  For example, used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).
     *&#x2F;
    draw: function(ctx, ignoreCache) {
      if (this._super(ctx, ignoreCache)) { return true; }
      &#x2F;&#x2F; this ensures we don&#x27;t have issues with display list changes that occur during a draw:
      var list = this.children.slice(0);
      for (var i = 0, l = list.length; i &lt; l; i++) {
        var child = list[i];
        if (!child.isVisible()) { continue; }
        &#x2F;&#x2F; draw the child:
        ctx.save();
        child.updateContext(ctx);
        child.draw(ctx);
        ctx.restore();
      }
      return true;
    },

    &#x2F;**
     * Adds a child to the top of the display list. You can also add multiple children, such as &quot;addChild(child1, child2, ...);&quot;.
     * Returns the child that was added, or the last child if multiple children were added.
     *
     * &lt;h4&gt;Example&lt;&#x2F;h4&gt;
     *     container.addChild(bitmapInstance, shapeInstance);
     *
     * @method addChild
     * @param {DisplayObject} child The display object to add.
     * @return {DisplayObject} The child that was added, or the last child if multiple children were added.
     *&#x2F;
    addChild: function(child) {
      if (child == null) { return child; }
      var l = arguments.length;
      if (l &gt; 1) {
        for (var i = 0; i &lt; l; i++) { this.addChild(arguments[i]); }
        return arguments[l - 1];
      }
      if (child.parent) { child.parent.removeChild(child); }
      child.parent = this;
      this.children.push(child);
      return child;
    },

    &#x2F;**
     * Adds a child to the display list at the specified index, bumping children at equal or greater indexes up one,
     * and setting its parent to this Container. You can also add multiple children, such as &quot;addChildAt(child1, child2, ..., index);&quot;.
     * The index must be between 0 and numChildren. For example, to add myShape under otherShape in the display list,
     * you could use: container.addChildAt(myShape, container.getChildIndex(otherShape)).
     * This would also bump otherShape&#x27;s index up by one.
     * Returns the last child that was added, or the last child if multiple children were added.
     * Fails silently if the index is out of range.
     *
     * @method addChildAt
     * @param {DisplayObject} child The display object to add.
     * @param {Number} index The index to add the child at.
     * @return {DisplayObject} The child that was added, or the last child if multiple children were added.
     *&#x2F;
    addChildAt: function(child, index) {
      var l = arguments.length;
      var idx = arguments[l - 1]; &#x2F;&#x2F; can&#x27;t use the same name as the index param or it replaces arguments[1]
      if (idx &lt; 0 || idx &gt; this.children.length) { return arguments[l - 2]; }
      if (l &gt; 2) {
        for (var i = 0; i &lt; l - 1; i++) { this.addChildAt(arguments[i], idx + i); }
        return arguments[l - 2];
      }
      if (child.parent) { child.parent.removeChild(child); }
      child.parent = this;
      this.children.splice(index, 0, child);
      return child;
    },

    &#x2F;**
     * Removes the specified child from the display list. Note that it is faster to use removeChildAt() if the index is
     * already known. You can also remove multiple children, such as &quot;removeChild(child1, child2, ...);&quot;.
     * Returns true if the child (or children) was removed, or false if it was not in the display list.
     *
     * @method removeChild
     * @param {DisplayObject} child The child to remove.
     * @return {Boolean} true if the child (or children) was removed, or false if it was not in the display list.
     *&#x2F;
    removeChild: function(child) {
      var l = arguments.length;
      if (l &gt; 1) {
        var good = true;
        for (var i = 0; i &lt; l; i++) { good = good &amp;&amp; this.removeChild(arguments[i]); }
        return good;
      }
      return this.removeChildAt(this.children.indexOf(child));
    },

    &#x2F;**
     * Removes the child at the specified index from the display list, and sets its parent to null. You can also remove
     * multiple children, such as &quot;removeChildAt(2, 7, ...);&quot;.
     * Returns true if the child (or children) was removed, or false if any index was out of range.
     *
     * @param {Number} index The index of the child to remove.
     * @return {Boolean} true if the child (or children) was removed, or false if any index was out of range.
     *&#x2F;
    removeChildAt: function(index) {
      var l = arguments.length;
      if (l &gt; 1) {
        var a = [];
        for (var i = 0; i &lt; l; i++) { a[i] = arguments[i]; }
        a.sort(function(a, b) { return b - a; });
        var good = true;
        for (var i = 0; i &lt; l; i++) { good = good &amp;&amp; this.removeChildAt(a[i]); }
        return good;
      }
      if (index &lt; 0 || index &gt; this.children.length - 1) { return false; }
      var child = this.children[index];
      if (child) { child.parent = null; }
      this.children.splice(index, 1);
      return true;
    },

    &#x2F;**
     * Removes all children from the display list.
     *
     * @method removeAllChildren
     *&#x2F;
    removeAllChildren: function() {
      var kids = this.children;
      while (kids.length) { kids.pop().parent = null; }
    },

    &#x2F;**
     * Returns the child at the specified index.
     *
     * @method getChildAt
     * @param {Number} index The index of the child to return.
     * @return {DisplayObject} The child at the specified index.
     *&#x2F;
    getChildAt: function(index) {
      return this.children[index];
    },

    &#x2F;**
     * Returns the child with the specified name.
     *
     * @method getChildByName
     * @param {String} name The name of the child to return.
     * @return {DisplayObject} The child with the specified name.
     *&#x2F;
    getChildByName: function(name) {
      var kids = this.children;
      for (var i = 0, l = kids.length; i &lt; l; i++) {
        if (kids[i].name == name) { return kids[i]; }
      }
      return null;
    },

    &#x2F;**
     * Performs an array sort operation on the child list.
     *
     * @method sortChildren
     * @param {Function} sortFunction the function to use to sort the child list. See javascript&#x27;s Array.sort
     *  documentation for details.
     *&#x2F;
    sortChildren: function(sortFunction) {
      this.children.sort(sortFunction);
    },

    &#x2F;**
     * Returns the index of the specified child in the display list, or -1 if it is not in the display list.
     *
     * @method getChildIndex
     * @param {DisplayObject} child The child to return the index of.
     * @return {Number} The index of the specified child. -1 if the child is not found.
     *&#x2F;
    getChildIndex: function(child) {
      return this.children.indexOf(child);
    },

    &#x2F;**
     * Returns the number of children in the display list.
     *
     * @method getNumChildren
     * @return {Number} The number of children in the display list.
     *&#x2F;
    getNumChildren: function() {
      return this.children.length;
    },

    &#x2F;**
     * Swaps the children at the specified indexes. Fails silently if either index is out of range.
     *
     * @param {Number} index1
     * @param {Number} index2
     * @method swapChildrenAt
     *&#x2F;
    swapChildrenAt: function(index1, index2) {
      var kids = this.children;
      var o1 = kids[index1];
      var o2 = kids[index2];
      if (!o1 || !o2) { return; }
      kids[index1] = o2;
      kids[index2] = o1;
    },

    &#x2F;**
     * Swaps the specified children&#x27;s depth in the display list.
     * Fails silently if either child is not a child of this Container.
     *
     * @param {DisplayObject} child1
     * @param {DisplayObject} child2
     * @method swapChildren
     *&#x2F;
    swapChildren: function(child1, child2) {
      var kids = this.children;
      var index1, index2;
      for (var i = 0, l = kids.length; i &lt; l; i++) {
        if (kids[i] == child1) { index1 = i; }
        if (kids[i] == child2) { index2 = i; }
        if (index1 != null &amp;&amp; index2 != null) { break; }
      }
      if (i == l) { return; } &#x2F;&#x2F; TODO: throw error?
      kids[index1] = child2;
      kids[index2] = child1;
    },

    &#x2F;**
     * Changes the depth of the specified child.
     * Fails silently if the child is not a child of this container, or the index is out of range.
     *
     * @param {DisplayObject} child
     * @param {Number} index
     * @method setChildIndex
     *&#x2F;
    setChildIndex: function(child, index) {
      var kids = this.children, l = kids.length;
      if (child.parent != this || index &lt; 0 || index &gt;= l) { return; }
      for (var i = 0; i &lt; l; i++) {
        if (kids[i] == child) { break; }
      }
      if (i == l || i == index) { return; }
      kids.splice(i, 1);
      if (index &lt; i) { index--; }
      kids.splice(index, 0, child);
    },

    &#x2F;**
     * Returns true if the specified display object either is this container or is a descendent.
     * (child, grandchild, etc) of this container.
     *
     * @method contains
     * @param {DisplayObject} child The DisplayObject to be checked.
     * @return {Boolean} true if the specified display object either is this container or is a descendent.
     *&#x2F;
    contains: function(child) {
      while (child) {
        if (child == this) { return true; }
        child = child.parent;
      }
      return false;
    },

    &#x2F;**
     * Tests whether the display object intersects the specified local point (ie. draws a pixel with alpha &gt; 0 at the
     * specified position). This ignores the alpha, shadow and compositeOperation of the display object, and all
     * transform properties including regX&#x2F;Y.
     *
     * @method hitTest
     * @param {Number} x The x position to check in the display object&#x27;s local coordinates.
     * @param {Number} y The y position to check in the display object&#x27;s local coordinates.
     * @return {Boolean} A Boolean indicating whether there is a visible section of a DisplayObject that overlaps the
     *  specified coordinates.
     *&#x2F;
    hitTest: function(x, y) {
      &#x2F;&#x2F; TODO: optimize to use the fast cache check where possible.
      return (this.getObjectUnderPoint(x, y) != null);
    },

    &#x2F;**
     * Returns an array of all display objects under the specified coordinates that are in this container&#x27;s display list.
     * This routine ignores any display objects with mouseEnabled set to false. The array will be sorted in order of
     * visual depth, with the top-most display object at index 0. This uses shape based hit detection, and can be an
     * expensive operation to run, so it is best to use it carefully. For example, if testing for objects under the
     * mouse, test on tick (instead of on mousemove), and only if the mouse&#x27;s position has changed.
     *
     * @method getObjectsUnderPoint
     * @param {Number} x The x position in the container to test.
     * @param {Number} y The y position in the container to test.
     * @return {Array} An Array of DisplayObjects under the specified coordinates.
     *&#x2F;
    getObjectsUnderPoint: function(x, y) {
      var arr = [];
      var pt = this.localToGlobal(x, y);
      this._getObjectsUnderPoint(pt.x, pt.y, arr);
      return arr;
    },

    &#x2F;**
     * Similar to getObjectsUnderPoint(), but returns only the top-most display object. This runs significantly faster
     * than getObjectsUnderPoint(), but is still an expensive operation. See getObjectsUnderPoint() for more information.
     *
     * @method getObjectUnderPoint
     * @param {Number} x The x position in the container to test.
     * @param {Number} y The y position in the container to test.
     * @return {DisplayObject} The top-most display object under the specified coordinates.
     *&#x2F;
    getObjectUnderPoint: function(x, y) {
      var pt = this.localToGlobal(x, y);
      return this._getObjectsUnderPoint(pt.x, pt.y);
    },

    &#x2F;**
     * Returns a clone of this Container. Some properties that are specific to this instance&#x27;s current context are
     * reverted to their defaults (for example .parent).
     *
     * @param {Boolean} recursive If true, all of the descendants of this container will be cloned recursively.
     *  If false, the properties of the container will be cloned, but the new instance will not have any children.
     * @return {Container} A clone of the current Container instance.
     *&#x2F;
    clone: function(recursive) {
      var o = new Container();
      this.cloneProps(o);
      if (recursive) {
        var arr = o.children = [];
        for (var i = 0, l = this.children.length; i &lt; l; i++) {
          var clone = this.children[i].clone(recursive);
          clone.parent = o;
          arr.push(clone);
        }
      }
      return o;
    },

    &#x2F;**
     * Returns a string representation of this object.
     *
     * @method toString
     * @return {String} a string representation of the instance.
     *&#x2F;
    toString: function() {
      return &quot;[Container (name=&quot; + this.name + &quot;)]&quot;;
    },

    &#x2F;**
     * @method _tick
     * @protected
     *&#x2F;
    _tick: function(params) {
      for (var i = this.children.length - 1; i &gt;= 0; i--) {
        var child = this.children[i];
        if (child._tick) { child._tick(params); }
      }
      this._super(params);
    },

    &#x2F;**
     * @method _getObjectsUnderPoint
     * @param {Number} x
     * @param {Number} y
     * @param {Array} arr
     * @param {Number} mouseEvents A bitmask indicating which event types to look for. Bit 1 specifies press &amp; click &amp;
     *  double click, bit 2 specifies it should look for mouse over and mouse out. This implementation may change.
     * @return {Array}
     * @protected
     *&#x2F;
    _getObjectsUnderPoint: function(x, y, arr, mouseEvents) {
      var ctx = DisplayObject._hitTestContext;
      var canvas = DisplayObject._hitTestCanvas;
      var mtx = this._matrix;
      var hasHandler = this._hasMouseHandler(mouseEvents);
      &#x2F;&#x2F; if we have a cache handy &amp; this has a handler, we can use it to do a quick check.
      &#x2F;&#x2F; we can&#x27;t use the cache for screening children, because they might have hitArea set.
      if (!this.hitArea &amp;&amp; this.cacheCanvas &amp;&amp; hasHandler) {
        this.getConcatenatedMatrix(mtx);
        ctx.setTransform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx - x, mtx.ty - y);
        ctx.globalAlpha = mtx.alpha;
        this.draw(ctx);
        if (this._testHit(ctx)) {
          canvas.width = 0;
          canvas.width = 1;
          return this;
        }
      }
      &#x2F;&#x2F; draw children one at a time, and check if we get a hit:
      var l = this.children.length;
      for (var i = l - 1; i &gt;= 0; i--) {
        var child = this.children[i];
        var hitArea = child.hitArea;
        if (!child.visible || (!hitArea &amp;&amp; !child.isVisible()) || (mouseEvents &amp;&amp; !child.mouseEnabled)) { continue; }
        var childHasHandler = mouseEvents &amp;&amp; child._hasMouseHandler(mouseEvents);
        &#x2F;&#x2F; if a child container has a handler and a hitArea then we only need to check its hitArea, so we can treat it as a normal DO:
        if (child instanceof Container &amp;&amp; !(hitArea &amp;&amp; childHasHandler)) {
          var result;
          if (hasHandler) {
            &#x2F;&#x2F; only concerned about the first hit, because this container is going to claim it anyway:
            result = child._getObjectsUnderPoint(x, y);
            if (result) { return this; }
          } else {
            result = child._getObjectsUnderPoint(x, y, arr, mouseEvents);
            if (!arr &amp;&amp; result) { return result; }
          }
        } else if (!mouseEvents || hasHandler || childHasHandler) {
          child.getConcatenatedMatrix(mtx);
          if (hitArea) {
            mtx.appendTransform(hitArea.x, hitArea.y, hitArea.scaleX, hitArea.scaleY, hitArea.rotation,
                hitArea.skewX, hitArea.skewY, hitArea.regX, hitArea.regY);
            mtx.alpha = hitArea.alpha;
          }
          ctx.globalAlpha = mtx.alpha;
          ctx.setTransform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx - x, mtx.ty - y);
          (hitArea || child).draw(ctx);
          if (!this._testHit(ctx)) { continue; }
          canvas.width = 0;
          canvas.width = 1;
          if (hasHandler) { return this; } else if (arr) { arr.push(child); } else { return child; }
        }
      }
      return null;
    }
  });

  return Container;

});
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>